"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_app_components_ParticleNetwork_tsx"],{

/***/ "(app-pages-browser)/./app/components/ParticleNetwork.tsx":
/*!********************************************!*\
  !*** ./app/components/ParticleNetwork.tsx ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ ParticleNetwork; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n// ============================================\n// 연결된 점들의 파티클 네트워크 애니메이션\n// ============================================\nfunction ParticleNetwork(param) {\n    let { isDark = true, particleColor, lineColor, density = 15000, connectionDistance = 120, maxConnections = 3, zIndex = -1 } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const particlesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const animationRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const sizeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        width: 0,\n        height: 0\n    });\n    // 파티클 초기화\n    const initParticles = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((width, height)=>{\n        const count = Math.floor(width * height / density);\n        const particles = [];\n        for(let i = 0; i < count; i++){\n            particles.push({\n                x: Math.random() * width,\n                y: Math.random() * height,\n                vx: (Math.random() - 0.5) * 0.3,\n                vy: (Math.random() - 0.5) * 0.3,\n                size: Math.random() * 1.5 + 0.5,\n                alpha: Math.random() * 0.5 + 0.3\n            });\n        }\n        particlesRef.current = particles;\n    }, [\n        density\n    ]);\n    // 렌더링 루프\n    const draw = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((ctx)=>{\n        const { width, height } = sizeRef.current;\n        const particles = particlesRef.current;\n        // 배경 클리어\n        ctx.clearRect(0, 0, width, height);\n        // 색상 설정\n        const pColor = particleColor || (isDark ? \"#ffffff\" : \"#000000\");\n        const lColor = lineColor || (isDark ? \"rgba(255,255,255,0.1)\" : \"rgba(0,0,0,0.05)\");\n        // 파티클 업데이트 및 그리기\n        particles.forEach((p, i)=>{\n            // 위치 업데이트\n            p.x += p.vx;\n            p.y += p.vy;\n            // 경계 래핑\n            if (p.x < 0) p.x = width;\n            else if (p.x > width) p.x = 0;\n            if (p.y < 0) p.y = height;\n            else if (p.y > height) p.y = 0;\n            // 파티클 그리기\n            ctx.beginPath();\n            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);\n            ctx.fillStyle = pColor;\n            ctx.globalAlpha = p.alpha * (isDark ? 0.6 : 0.3);\n            ctx.fill();\n            // 연결선 그리기 (성능 최적화: 제한된 연결)\n            let connections = 0;\n            for(let j = i + 1; j < particles.length && connections < maxConnections; j++){\n                const p2 = particles[j];\n                const dx = p.x - p2.x;\n                const dy = p.y - p2.y;\n                const dist = Math.sqrt(dx * dx + dy * dy);\n                if (dist < connectionDistance) {\n                    ctx.beginPath();\n                    ctx.moveTo(p.x, p.y);\n                    ctx.lineTo(p2.x, p2.y);\n                    ctx.strokeStyle = lColor;\n                    ctx.globalAlpha = (1 - dist / connectionDistance) * (isDark ? 0.4 : 0.2);\n                    ctx.lineWidth = 0.5;\n                    ctx.stroke();\n                    connections++;\n                }\n            }\n        });\n        ctx.globalAlpha = 1;\n    }, [\n        isDark,\n        particleColor,\n        lineColor,\n        connectionDistance,\n        maxConnections\n    ]);\n    // 애니메이션 루프\n    const animate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        const canvas = canvasRef.current;\n        const ctx = canvas === null || canvas === void 0 ? void 0 : canvas.getContext(\"2d\");\n        if (ctx) {\n            draw(ctx);\n        }\n        animationRef.current = requestAnimationFrame(animate);\n    }, [\n        draw\n    ]);\n    // 리사이즈 핸들러\n    const handleResize = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const width = window.innerWidth;\n        const height = window.innerHeight;\n        canvas.width = width;\n        canvas.height = height;\n        sizeRef.current = {\n            width,\n            height\n        };\n        initParticles(width, height);\n    }, [\n        initParticles\n    ]);\n    // 초기화 및 클린업\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        handleResize();\n        window.addEventListener(\"resize\", handleResize);\n        animationRef.current = requestAnimationFrame(animate);\n        return ()=>{\n            window.removeEventListener(\"resize\", handleResize);\n            if (animationRef.current) {\n                cancelAnimationFrame(animationRef.current);\n            }\n        };\n    }, [\n        handleResize,\n        animate\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        ref: canvasRef,\n        className: \"fixed inset-0 pointer-events-none\",\n        style: {\n            zIndex\n        },\n        \"aria-hidden\": \"true\"\n    }, void 0, false, {\n        fileName: \"D:\\\\exe.blue\\\\aifarm\\\\apps\\\\web\\\\app\\\\components\\\\ParticleNetwork.tsx\",\n        lineNumber: 170,\n        columnNumber: 5\n    }, this);\n}\n_s(ParticleNetwork, \"3e55V/Hw/lgiWOgrNFK7QD4X/LQ=\");\n_c = ParticleNetwork;\nvar _c;\n$RefreshReg$(_c, \"ParticleNetwork\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL1BhcnRpY2xlTmV0d29yay50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBRThEO0FBZ0M5RCwrQ0FBK0M7QUFDL0MseUJBQXlCO0FBQ3pCLCtDQUErQztBQUVoQyxTQUFTSSxnQkFBZ0IsS0FRakI7UUFSaUIsRUFDdENDLFNBQVMsSUFBSSxFQUNiQyxhQUFhLEVBQ2JDLFNBQVMsRUFDVEMsVUFBVSxLQUFLLEVBQ2ZDLHFCQUFxQixHQUFHLEVBQ3hCQyxpQkFBaUIsQ0FBQyxFQUNsQkMsU0FBUyxDQUFDLENBQUMsRUFDVSxHQVJpQjs7SUFTdEMsTUFBTUMsWUFBWVgsNkNBQU1BLENBQW9CO0lBQzVDLE1BQU1ZLGVBQWVaLDZDQUFNQSxDQUFhLEVBQUU7SUFDMUMsTUFBTWEsZUFBZWIsNkNBQU1BLENBQWdCO0lBQzNDLE1BQU1jLFVBQVVkLDZDQUFNQSxDQUFDO1FBQUVlLE9BQU87UUFBR0MsUUFBUTtJQUFFO0lBRTdDLFVBQVU7SUFDVixNQUFNQyxnQkFBZ0JmLGtEQUFXQSxDQUFDLENBQUNhLE9BQWVDO1FBQ2hELE1BQU1FLFFBQVFDLEtBQUtDLEtBQUssQ0FBQyxRQUFTSixTQUFVVDtRQUM1QyxNQUFNYyxZQUF3QixFQUFFO1FBRWhDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSixPQUFPSSxJQUFLO1lBQzlCRCxVQUFVRSxJQUFJLENBQUM7Z0JBQ2JDLEdBQUdMLEtBQUtNLE1BQU0sS0FBS1Y7Z0JBQ25CVyxHQUFHUCxLQUFLTSxNQUFNLEtBQUtUO2dCQUNuQlcsSUFBSSxDQUFDUixLQUFLTSxNQUFNLEtBQUssR0FBRSxJQUFLO2dCQUM1QkcsSUFBSSxDQUFDVCxLQUFLTSxNQUFNLEtBQUssR0FBRSxJQUFLO2dCQUM1QkksTUFBTVYsS0FBS00sTUFBTSxLQUFLLE1BQU07Z0JBQzVCSyxPQUFPWCxLQUFLTSxNQUFNLEtBQUssTUFBTTtZQUMvQjtRQUNGO1FBRUFiLGFBQWFtQixPQUFPLEdB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QyxHQUFHO1FBQUMxQjtLQUFLO0lBRVQsV0FBVztJQUNYLE1BQU04QixlQUFlNUQsa0RBQVdBLENBQUM7UUFDL0IsTUFBTXlELFNBQVNoRCxVQUFVb0IsT0FBTztRQUNoQyxJQUFJLENBQUM0QixRQUFRO1FBRWIsTUFBTTVDLFFBQVFnRCxPQUFPQyxVQUFVO1FBQy9CLE1BQU1oRCxTQUFTK0MsT0FBT0UsV0FBVztRQUVqQ04sT0FBTzVDLEtBQUssR0FBR0E7UUFDZjRDLE9BQU8zQyxNQUFNLEdBQUdBO1FBQ2hCRixRQUFRaUIsT0FBTyxHQUFHO1lBQUVoQjtZQUFPQztRQUFPO1FBRWxDQyxjQUFjRixPQUFPQztJQUN2QixHQUFHO1FBQUNDO0tBQWM7SUFFbEIsWUFBWTtJQUNaaEIsZ0RBQVNBLENBQUM7UUFDUjZEO1FBRUFDLE9BQU9HLGdCQUFnQixDQUFDLFVBQVVKO1FBQ2xDakQsYUFBYWtCLE9BQU8sR0FBRzhCLHNCQUFzQkg7UUFFN0MsT0FBTztZQUNMSyxPQUFPSSxtQkFBbUIsQ0FBQyxVQUFVTDtZQUNyQyxJQUFJakQsYUFBYWtCLE9BQU8sRUFBRTtnQkFDeEJxQyxxQkFBcUJ2RCxhQUFha0IsT0FBTztZQUMzQztRQUNGO0lBQ0YsR0FBRztRQUFDK0I7UUFBY0o7S0FBUTtJQUUxQixxQkFDRSw4REFBQ0M7UUFDQ1UsS0FBSzFEO1FBQ0wyRCxXQUFVO1FBQ1ZDLE9BQU87WUFBRTdEO1FBQU87UUFDaEI4RCxlQUFZOzs7Ozs7QUFHbEI7R0ExSXdCckU7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2NvbXBvbmVudHMvUGFydGljbGVOZXR3b3JrLnRzeD9kZDBlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcclxuXHJcbmltcG9ydCBSZWFjdCwgeyB1c2VSZWYsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBUeXBlc1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuaW50ZXJmYWNlIFBhcnRpY2xlIHtcclxuICB4OiBudW1iZXI7XHJcbiAgeTogbnVtYmVyO1xyXG4gIHZ4OiBudW1iZXI7XHJcbiAgdnk6IG51bWJlcjtcclxuICBzaXplOiBudW1iZXI7XHJcbiAgYWxwaGE6IG51bWJlcjtcclxufVxyXG5cclxuaW50ZXJmYWNlIFBhcnRpY2xlTmV0d29ya1Byb3BzIHtcclxuICAvKiog64uk7YGs66qo65OcIOyXrOu2gCAqL1xyXG4gIGlzRGFyaz86IGJvb2xlYW47XHJcbiAgLyoqIO2MjO2LsO2BtCDsg4nsg4EgKENTUyDsg4nsg4HqsJIpICovXHJcbiAgcGFydGljbGVDb2xvcj86IHN0cmluZztcclxuICAvKiog7Jew6rKw7ISgIOyDieyDgSAoQ1NTIOyDieyDgeqwkikgKi9cclxuICBsaW5lQ29sb3I/OiBzdHJpbmc7XHJcbiAgLyoqIO2MjO2LsO2BtCDrsIDrj4QgKOuCruydhOyImOuhnSDrp47snYwsIOq4sOuzuDogMTUwMDApICovXHJcbiAgZGVuc2l0eT86IG51bWJlcjtcclxuICAvKiog7Jew6rKwIOy1nOuMgCDqsbDrpqwgKHB4KSAqL1xyXG4gIGNvbm5lY3Rpb25EaXN0YW5jZT86IG51bWJlcjtcclxuICAvKiog7LWc64yAIOyXsOqysOyEoCDsiJggKi9cclxuICBtYXhDb25uZWN0aW9ucz86IG51bWJlcjtcclxuICAvKiogei1pbmRleCDshKTsoJUgKi9cclxuICB6SW5kZXg/OiBudW1iZXI7XHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIOyXsOqysOuQnCDsoJDrk6TsnZgg7YyM7Yuw7YG0IOuEpO2KuOybjO2BrCDslaDri4jrqZTsnbTshZhcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBhcnRpY2xlTmV0d29yayh7XHJcbiAgaXNEYXJrID0gdHJ1ZSxcclxuICBwYXJ0aWNsZUNvbG9yLFxyXG4gIGxpbmVDb2xvcixcclxuICBkZW5zaXR5ID0gMTUwMDAsXHJcbiAgY29ubmVjdGlvbkRpc3RhbmNlID0gMTIwLFxyXG4gIG1heENvbm5lY3Rpb25zID0gMyxcclxuICB6SW5kZXggPSAtMSxcclxufTogUGFydGljbGVOZXR3b3JrUHJvcHMpIHtcclxuICBjb25zdCBjYW52YXNSZWYgPSB1c2VSZWY8SFRNTENhbnZhc0VsZW1lbnQ+KG51bGwpO1xyXG4gIGNvbnN0IHBhcnRpY2xlc1JlZiA9IHVzZVJlZjxQYXJ0aWNsZVtdPihbXSk7XHJcbiAgY29uc3QgYW5pbWF0aW9uUmVmID0gdXNlUmVmPG51bWJlciB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IHNpemVSZWYgPSB1c2VSZWYoeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pO1xyXG5cclxuICAvLyDtjIzti7DtgbQg7LSI6riw7ZmUXHJcbiAgY29uc3QgaW5pdFBhcnRpY2xlcyA9IHVzZUNhbGxiYWNrKCh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikgPT4ge1xyXG4gICAgY29uc3QgY291bnQgPSBNYXRoLmZsb29yKCh3aWR0aCAqIGhlaWdodCkgLyBkZW5zaXR5KTtcclxuICAgIGNvbnN0IHBhcnRpY2xlczogUGFydGljbGVbXSA9IFtdO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICBwYXJ0aWNsZXMucHVzaCh7XHJcbiAgICAgICAgeDogTWF0aC5yYW5kb20oKSAqIHdpZHRoLFxyXG4gICAgICAgIHk6IE1hdGgucmFuZG9tKCkgKiBoZWlnaHQsXHJcbiAgICAgICAgdng6IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDAuMyxcclxuICAgICAgICB2eTogKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC4zLFxyXG4gICAgICAgIHNpemU6IE1hdGgucmFuZG9tKCkgKiAxLjUgKyAwLjUsXHJcbiAgICAgICAgYWxwaGE6IE1hdGgucmFuZG9tKCkgKiAwLjUgKyAwLjMsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHBhcnRpY2xlc1JlZi5jdXJyZW50ID0gcGFydGljbGVzO1xyXG4gIH0sIFtkZW5zaXR5XSk7XHJcblxyXG4gIC8vIOugjOuNlOungSDro6jtlIRcclxuICBjb25zdCBkcmF3ID0gdXNlQ2FsbGJhY2soKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSA9PiB7XHJcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHNpemVSZWYuY3VycmVudDtcclxuICAgIGNvbnN0IHBhcnRpY2xlcyA9IHBhcnRpY2xlc1JlZi5jdXJyZW50O1xyXG4gICAgXHJcbiAgICAvLyDrsLDqsr0g7YG066as7Ja0XHJcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgIC8vIOyDieyDgSDshKTsoJVcclxuICAgIGNvbnN0IHBDb2xvciA9IHBhcnRpY2xlQ29sb3IgfHwgKGlzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJyk7XHJcbiAgICBjb25zdCBsQ29sb3IgPSBsaW5lQ29sb3IgfHwgKGlzRGFyayA/ICdyZ2JhKDI1NSwyNTUsMjU1LDAuMSknIDogJ3JnYmEoMCwwLDAsMC4wNSknKTtcclxuXHJcbiAgICAvLyDtjIzti7DtgbQg7JeF642w7J207Yq4IOuwjyDqt7jrpqzquLBcclxuICAgIHBhcnRpY2xlcy5mb3JFYWNoKChwLCBpKSA9PiB7XHJcbiAgICAgIC8vIOychOy5mCDsl4XrjbDsnbTtirhcclxuICAgICAgcC54ICs9IHAudng7XHJcbiAgICAgIHAueSArPSBwLnZ5O1xyXG5cclxuICAgICAgLy8g6rK96rOEIOuemO2VkVxyXG4gICAgICBpZiAocC54IDwgMCkgcC54ID0gd2lkdGg7XHJcbiAgICAgIGVsc2UgaWYgKHAueCA+IHdpZHRoKSBwLnggPSAwO1xyXG4gICAgICBpZiAocC55IDwgMCkgcC55ID0gaGVpZ2h0O1xyXG4gICAgICBlbHNlIGlmIChwLnkgPiBoZWlnaHQpIHAueSA9IDA7XHJcblxyXG4gICAgICAvLyDtjIzti7DtgbQg6re466as6riwXHJcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgY3R4LmFyYyhwLngsIHAueSwgcC5zaXplLCAwLCBNYXRoLlBJICogMik7XHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBwQ29sb3I7XHJcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHAuYWxwaGEgKiAoaXNEYXJrID8gMC42IDogMC4zKTtcclxuICAgICAgY3R4LmZpbGwoKTtcclxuXHJcbiAgICAgIC8vIOyXsOqysOyEoCDqt7jrpqzquLAgKOyEseuKpSDstZzsoIHtmZQ6IOygnO2VnOuQnCDsl7DqsrApXHJcbiAgICAgIGxldCBjb25uZWN0aW9ucyA9IDA7XHJcbiAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHBhcnRpY2xlcy5sZW5ndGggJiYgY29ubmVjdGlvbnMgPCBtYXhDb25uZWN0aW9uczsgaisrKSB7XHJcbiAgICAgICAgY29uc3QgcDIgPSBwYXJ0aWNsZXNbal07XHJcbiAgICAgICAgY29uc3QgZHggPSBwLnggLSBwMi54O1xyXG4gICAgICAgIGNvbnN0IGR5ID0gcC55IC0gcDIueTtcclxuICAgICAgICBjb25zdCBkaXN0ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcclxuXHJcbiAgICAgICAgaWYgKGRpc3QgPCBjb25uZWN0aW9uRGlzdGFuY2UpIHtcclxuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgIGN0eC5tb3ZlVG8ocC54LCBwLnkpO1xyXG4gICAgICAgICAgY3R4LmxpbmVUbyhwMi54LCBwMi55KTtcclxuICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxDb2xvcjtcclxuICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9ICgxIC0gZGlzdCAvIGNvbm5lY3Rpb25EaXN0YW5jZSkgKiAoaXNEYXJrID8gMC40IDogMC4yKTtcclxuICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAwLjU7XHJcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgICBjb25uZWN0aW9ucysrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcclxuICB9LCBbaXNEYXJrLCBwYXJ0aWNsZUNvbG9yLCBsaW5lQ29sb3IsIGNvbm5lY3Rpb25EaXN0YW5jZSwgbWF4Q29ubmVjdGlvbnNdKTtcclxuXHJcbiAgLy8g7JWg64uI66mU7J207IWYIOujqO2UhFxyXG4gIGNvbnN0IGFuaW1hdGUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcclxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcz8uZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgIFxyXG4gICAgaWYgKGN0eCkge1xyXG4gICAgICBkcmF3KGN0eCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGFuaW1hdGlvblJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gIH0sIFtkcmF3XSk7XHJcblxyXG4gIC8vIOumrOyCrOydtOymiCDtlbjrk6Trn6xcclxuICBjb25zdCBoYW5kbGVSZXNpemUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcclxuICAgIGlmICghY2FudmFzKSByZXR1cm47XHJcblxyXG4gICAgY29uc3Qgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcclxuICAgIGNvbnN0IGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcclxuICAgIFxyXG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XHJcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgc2l6ZVJlZi5jdXJyZW50ID0geyB3aWR0aCwgaGVpZ2h0IH07XHJcbiAgICBcclxuICAgIGluaXRQYXJ0aWNsZXMod2lkdGgsIGhlaWdodCk7XHJcbiAgfSwgW2luaXRQYXJ0aWNsZXNdKTtcclxuXHJcbiAgLy8g7LSI6riw7ZmUIOuwjyDtgbTrprDsl4VcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaGFuZGxlUmVzaXplKCk7XHJcbiAgICBcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xyXG4gICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XHJcbiAgICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvblJlZi5jdXJyZW50KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9LCBbaGFuZGxlUmVzaXplLCBhbmltYXRlXSk7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8Y2FudmFzXHJcbiAgICAgIHJlZj17Y2FudmFzUmVmfVxyXG4gICAgICBjbGFzc05hbWU9XCJmaXhlZCBpbnNldC0wIHBvaW50ZXItZXZlbnRzLW5vbmVcIlxyXG4gICAgICBzdHlsZT17eyB6SW5kZXggfX1cclxuICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcclxuICAgIC8+XHJcbiAgKTtcclxufVxyXG5cclxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlUmVmIiwidXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCJQYXJ0aWNsZU5ldHdvcmsiLCJpc0RhcmsiLCJwYXJ0aWNsZUNvbG9yIiwibGluZUNvbG9yIiwiZGVuc2l0eSIsImNvbm5lY3Rpb25EaXN0YW5jZSIsIm1heENvbm5lY3Rpb25zIiwiekluZGV4IiwiY2FudmFzUmVmIiwicGFydGljbGVzUmVmIiwiYW5pbWF0aW9uUmVmIiwic2l6ZVJlZiIsIndpZHRoIiwiaGVpZ2h0IiwiaW5pdFBhcnRpY2xlcyIsImNvdW50IiwiTWF0aCIsImZsb29yIiwicGFydGljbGVzIiwiaSIsInB1c2giLCJ4IiwicmFuZG9tIiwieSIsInZ4IiwidnkiLCJzaXplIiwiYWxwaGEiLCJjdXJyZW50IiwiZHJhdyIsImN0eCIsImNsZWFyUmVjdCIsInBDb2xvciIsImxDb2xvciIsImZvckVhY2giLCJwIiwiYmVnaW5QYXRoIiwiYXJjIiwiUEkiLCJmaWxsU3R5bGUiLCJnbG9iYWxBbHBoYSIsImZpbGwiLCJjb25uZWN0aW9ucyIsImoiLCJsZW5ndGgiLCJwMiIsImR4IiwiZHkiLCJkaXN0Iiwic3FydCIsIm1vdmVUbyIsImxpbmVUbyIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwic3Ryb2tlIiwiYW5pbWF0ZSIsImNhbnZhcyIsImdldENvbnRleHQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJoYW5kbGVSZXNpemUiLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicmVmIiwiY2xhc3NOYW1lIiwic3R5bGUiLCJhcmlhLWhpZGRlbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/ParticleNetwork.tsx\n"));

/***/ })

}]);